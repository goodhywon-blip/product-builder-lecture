<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="google-adsense-account" content="ca-pub-7713287823701747">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Name ‚Üí Hangul</title>
  <meta name="description" content="Write your English name in Hangul. Dictionary-first accuracy + smart fallback. Browser-only."/>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7713287823701747" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="wrap">
    <header class="reveal">
      <div class="brand">
        <div class="mark" aria-hidden="true"></div>
        <div>
          <h1>Name ‚Üí Hangul</h1>
          <p>English name ‚Üí natural Hangul spelling ¬∑ browser-only</p>
        </div>
      </div>
      <div class="top-actions">
        <div class="pill" id="clearBtn" title="Clear">
          <span aria-hidden="true">‚å´</span><span>Reset</span>
        </div>
      </div>
    </header>

    <nav class="nav reveal delay-1" aria-label="Page">
      <a href="#tool">Tool</a>
      <a href="#how">How it works</a>
      <a href="#examples">Examples</a>
      <a href="#community">Community</a>
      <a href="#faq">FAQ</a>
      <a href="#privacy">Privacy</a>
      <a href="#contact">Contact</a>
      <a href="privacy.html">Privacy Policy</a>
      <a href="terms.html">Terms</a>
      <a href="about.html">About</a>
    </nav>

    <section class="hero reveal delay-2">
      <h2 class="headline">Write your name in Hangul</h2>
      <p class="subhead">
        Dictionary-first for accuracy. If something looks wrong, save a correction once ‚Äî
        your browser will remember it. This site is designed for English speakers who want
        a clean, readable Hangul spelling for personal or creative use.
      </p>
    </section>

    <section id="tool" class="grid">
      <section class="card reveal delay-3">
        <div class="inner">
          <div class="badge">English-only ¬∑ No server ¬∑ No AI tokens</div>

          <div class="row">
            <div class="field" role="group" aria-label="Name input">
              <div class="icon" aria-hidden="true">Aa</div>
              <input id="nameInput" placeholder="e.g., Jacob / Jason / Michael" autocomplete="off" />
            </div>
            <button class="btn primary" id="convertBtn">Convert</button>
          </div>

          <div class="results" id="results"></div>

          <div class="hint">
            Tip: click <b>Fix</b> to pre-fill the community suggestion form.
          </div>
        </div>
      </section>
    </section>

    <section id="community" class="section reveal delay-2">
      <div class="section-head">
        <h3>Community suggestions</h3>
        <span>Reviewed</span>
      </div>
      <p class="text">Community suggestions are reviewed before becoming official.</p>
      <div class="row" style="margin-top:10px;">
        <div class="field" style="flex:1 1 240px">
          <div class="icon" aria-hidden="true">EN</div>
          <input id="suggestKey" placeholder="Name key" autocomplete="off" />
        </div>
        <div class="field" style="flex:1 1 240px">
          <div class="icon" aria-hidden="true">Í∞Ä</div>
          <input id="suggestHangul" placeholder="Suggested Hangul" autocomplete="off" />
        </div>
      </div>
      <div class="row" style="margin-top:10px;">
        <button class="btn" id="submitSuggestionBtn">Submit suggestion (reviewed before publication)</button>
      </div>
      <div class="community-list" id="communityList"></div>
    </section>

    <section id="how" class="section reveal delay-3">
      <div class="section-head">
        <h3>How it works</h3>
        <span>Accuracy first</span>
      </div>
      <p class="text">
        The converter follows a simple priority order to reduce weird spellings. First it checks a
        built-in dictionary of common names. If no match exists, it applies a rule-based fallback
        that approximates English pronunciation into Hangul syllables. You can override any result
        by saving a custom spelling, which always wins.
      </p>
      <div class="card-grid">
        <div class="mini-card">
          <b>1) Dictionary-first</b>
          <p class="text">Common names are mapped to the most natural Hangul spelling.</p>
        </div>
        <div class="mini-card">
          <b>2) Rule-based fallback</b>
          <p class="text">If a name is not found, the converter builds syllables from vowel/consonant patterns.</p>
        </div>
        <div class="mini-card">
          <b>3) Custom fixes</b>
          <p class="text">Save your own spelling once; your browser remembers it.</p>
        </div>
      </div>
    </section>

    <section id="examples" class="section reveal delay-4">
      <div class="section-head">
        <h3>Example conversions</h3>
        <span>Realistic output</span>
      </div>
      <table class="table" aria-label="Example conversions">
        <thead>
          <tr>
            <th>English</th>
            <th>Hangul (recommended)</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Jacob</td>
            <td>Ï†úÏù¥ÏΩ•</td>
            <td>Dictionary match</td>
          </tr>
          <tr>
            <td>Thomas</td>
            <td>ÌÜ†Î®∏Ïä§</td>
            <td>Dictionary match</td>
          </tr>
          <tr>
            <td>Charlie</td>
            <td>Ï∞∞Î¶¨</td>
            <td>Dictionary match</td>
          </tr>
          <tr>
            <td>Avery</td>
            <td>ÏóêÏù¥Î∏åÎ¶¨</td>
            <td>Rule-based fallback</td>
          </tr>
          <tr>
            <td>Brooklyn</td>
            <td>Î∏åÎ£®ÌÅ¥Î¶∞</td>
            <td>Rule-based fallback</td>
          </tr>
        </tbody>
      </table>
      <p class="text">Names vary by preference. If you want a different spelling, save it in the custom dictionary.</p>
    </section>

    <section id="faq" class="section reveal delay-5">
      <div class="section-head">
        <h3>FAQ</h3>
        <span>Quick answers</span>
      </div>
      <div class="faq">
        <div class="faq-item">
          <h4>Is this an official romanization tool?</h4>
          <p>No. This is a practical name spelling helper based on common usage and a simple rule fallback.</p>
        </div>
        <div class="faq-item">
          <h4>Will the result be ‚Äúcorrect‚Äù?</h4>
          <p>There is no single official spelling for many names. If you prefer a different spelling, save it.</p>
        </div>
        <div class="faq-item">
          <h4>Do you store my name?</h4>
          <p>No. Everything runs in your browser. Only your custom dictionary is saved locally.</p>
        </div>
        <div class="faq-item">
          <h4>Can I use this on mobile?</h4>
          <p>Yes. The site is responsive and runs entirely in the browser.</p>
        </div>
      </div>
    </section>

    <section id="privacy" class="section reveal delay-3">
      <div class="section-head">
        <h3>Privacy</h3>
        <span>No server</span>
      </div>
      <p class="text">
        This tool does not send your input to a server. The converter runs on-device. If you save a
        custom spelling, it is stored only in your browser via localStorage. For details, read the
        full privacy policy page.
      </p>
    </section>

    <section id="contact" class="section reveal delay-4">
      <div class="section-head">
        <h3>Contact</h3>
        <span>Feedback welcome</span>
      </div>
      <p class="text">
        If you find a name that looks wrong or want to suggest improvements, please use the contact
        page and include the English spelling and your preferred Hangul output. You can also reach
        us at <b>goodhywon@gmail.com</b>.
      </p>
    </section>

    <footer class="reveal delay-5">
      ¬© <span id="year"></span> Name ‚Üí Hangul ¬∑ Privacy-friendly (localStorage only) ¬∑
      Contact: <b>goodhywon@gmail.com</b> ¬∑
      <a href="privacy.html">Privacy</a> ¬∑ <a href="terms.html">Terms</a> ¬∑ <a href="contact.html">Contact</a>
    </footer>
  </div>

  <div class="toast" id="toast">Copied!</div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
    import {
      getFirestore, doc, getDoc, setDoc, updateDoc, serverTimestamp,
      collection, query, where, orderBy, limit, getDocs, runTransaction, enableIndexedDbPersistence
    } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";

    // ------------------------------
    // Firebase config (replace with your project values)
    // ------------------------------
    const firebaseConfig = {
      apiKey: "AIzaSyBU-bWMdsusXQ3Uc_vxOvRlpp2FsNrtszc",
      authDomain: "productbuilder-week1-fccc8.firebaseapp.com",
      projectId: "productbuilder-week1-fccc8",
      storageBucket: "productbuilder-week1-fccc8.firebasestorage.app",
      messagingSenderId: "652260101175",
      appId: "1:652260101175:web:d905f7b2ff34e0a96043b2"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    enableIndexedDbPersistence(db).catch(() => {});

    // ------------------------------
    // Storage keys
    // ------------------------------
    const CUSTOM_DICT_KEY = "nh_custom_dict";
    const LAST_SUGGESTION_KEY = "nh_last_suggestion_ts";

    // ------------------------------
    // Built-in dictionary (seed)
    // ------------------------------
    const BUILTIN_DICT = new Map([
      ["jacob", ["Ï†úÏù¥ÏΩ•"]],
      ["jason", ["Ï†úÏù¥Ïä®"]],
      ["mason", ["Î©îÏù¥Ïä®"]],
      ["jackson", ["Ïû≠Ïä®","Ïû¨Ïª§Ïä®"]],
      ["michael", ["ÎßàÏù¥ÌÅ¥"]],
      ["william", ["ÏúåÎ¶¨ÏóÑ","ÏúåÎ¶¨Ïïî"]],
      ["thomas", ["ÌÜ†Î®∏Ïä§","ÌÜ†ÎßàÏä§"]],
      ["james", ["Ï†úÏûÑÏä§"]],
      ["andrew", ["Ïï§ÎìúÎ£®"]],
      ["henry", ["Ìó®Î¶¨"]],
      ["george", ["Ï°∞ÏßÄ"]],
      ["david", ["Îç∞Ïù¥ÎπÑÎìú"]],
      ["john", ["Ï°¥"]],
      ["noah", ["ÎÖ∏ÏïÑ"]],
      ["isaac", ["ÏïÑÏù¥Ïûë","Ïù¥ÏÇ≠"]],
      ["benjamin", ["Î≤§ÏûêÎØº"]],
      ["alexander", ["ÏïåÎ†âÏÇ∞Îçî","ÏïåÎ†âÏÇ∞ÎçîÎ•¥"]],
      ["charlie", ["Ï∞∞Î¶¨"]],
      ["harry", ["Ìï¥Î¶¨"]],
      ["leo", ["Î†àÏò§"]],
      ["liam", ["Î¶¨Ïïî"]],
      ["oliver", ["Ïò¨Î¶¨Î≤Ñ"]],
      ["jack", ["Ïû≠"]]
    ]);

    // ------------------------------
    // DOM
    // ------------------------------
    const $ = (s) => document.querySelector(s);
    const nameInput = $("#nameInput");
    const resultsEl = $("#results");
    const toast = $("#toast");
    const communityList = $("#communityList");

    const suggestKey = $("#suggestKey");
    const suggestHangul = $("#suggestHangul");
    const submitSuggestionBtn = $("#submitSuggestionBtn");

    $("#year").textContent = new Date().getFullYear();

    let currentUser = null;
    let canonicalCache = new Map();

    onAuthStateChanged(auth, (user) => {
      currentUser = user;
      if (!user) {
        signInAnonymously(auth).catch(() => {});
      }
    });

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }

    function showToast(msg="Copied!") {
      toast.textContent = msg;
      toast.classList.add("show");
      setTimeout(() => toast.classList.remove("show"), 900);
    }

    async function copyText(t) {
      try {
        await navigator.clipboard.writeText(t);
        showToast("Copied!");
      } catch {
        const ta = document.createElement("textarea");
        ta.value = t;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
        showToast("Copied!");
      }
    }

    $("#clearBtn").addEventListener("click", () => {
      nameInput.value = "";
      resultsEl.innerHTML = "";
      communityList.innerHTML = "";
      nameInput.focus();
    });

    // ------------------------------
    // Custom dictionary (highest priority)
    // ------------------------------
    function loadCustomDict() {
      try {
        const obj = JSON.parse(localStorage.getItem(CUSTOM_DICT_KEY) || "{}");
        if (obj && typeof obj === "object") return obj;
      } catch {}
      return {};
    }


    function normalizeEnglishKey(s) {
      return (s || "")
        .trim()
        .toLowerCase()
        .replace(/[^a-z\s'-]/g, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    function normalizeHangulValue(s) {
      return (s || "").trim().replace(/\s+/g, " ").trim();
    }


    // ------------------------------
    // Rule-based fallback
    // ------------------------------
    const CHO  = ["„Ñ±","„Ñ≤","„Ñ¥","„Ñ∑","„Ñ∏","„Ñπ","„ÖÅ","„ÖÇ","„ÖÉ","„ÖÖ","„ÖÜ","„Öá","„Öà","„Öâ","„Öä","„Öã","„Öå","„Öç","„Öé"];
    const JUNG = ["„Öè","„Öê","„Öë","„Öí","„Öì","„Öî","„Öï","„Öñ","„Öó","„Öò","„Öô","„Öö","„Öõ","„Öú","„Öù","„Öû","„Öü","„Ö†","„Ö°","„Ö¢","„Ö£"];
    const JONG = ["", "„Ñ±","„Ñ≤","„Ñ≥","„Ñ¥","„Ñµ","„Ñ∂","„Ñ∑","„Ñπ","„Ñ∫","„Ñª","„Ñº","„ÑΩ","„Ñæ","„Ñø","„ÖÄ","„ÖÅ","„ÖÇ","„ÖÑ","„ÖÖ","„ÖÜ","„Öá","„Öà","„Öä","„Öã","„Öå","„Öç","„Öé"];
    const choIndex  = Object.fromEntries(CHO.map((c,i)=>[c,i]));
    const jungIndex = Object.fromEntries(JUNG.map((c,i)=>[c,i]));
    const jongIndex = Object.fromEntries(JONG.map((c,i)=>[c,i]));

    function composeSyllable(cho, jung, jong="") {
      if (!(cho in choIndex)) cho = "„Öá";
      if (!(jung in jungIndex)) jung = "„Öè";
      if (!(jong in jongIndex)) jong = "";
      const base = 0xAC00;
      const code = base + (choIndex[cho] * 21 * 28) + (jungIndex[jung] * 28) + jongIndex[jong];
      return String.fromCharCode(code);
    }

    const VOWELS = [
      ["eigh","ÏóêÏù¥"], ["igh","ÏïÑÏù¥"],
      ["eau","Ïò§"], ["ieu","Ïú†"],
      ["ai","ÏóêÏù¥"], ["ay","ÏóêÏù¥"],
      ["ea","Ïù¥"], ["ee","Ïù¥"], ["ie","Ïù¥"], ["ei","Ïù¥"],
      ["oo","Ïö∞"], ["ow","ÏïÑÏö∞"], ["ou","ÏïÑÏö∞"],
      ["au","Ïò§"], ["aw","Ïò§"],
      ["oi","Ïò§Ïù¥"], ["oy","Ïò§Ïù¥"],
      ["oa","Ïò§"], ["oe","Ïò§"],
      ["a","ÏïÑ"], ["e","Ïóê"], ["i","Ïù¥"], ["o","Ïò§"], ["u","Ïö∞"], ["y","Ïù¥"]
    ];

    const CONS = [
      ["tch","„Öä"], ["ch","„Öä"], ["sh","„ÖÖ"], ["ph","„Öç"],
      ["th","„Öå"], ["ck","„Öã"], ["ng","„Öá"], ["qu","„Öã"], ["wh","„Öé"],
      ["kn","„Ñ¥"], ["wr","„Ñπ"], ["ps","„ÖÖ"], ["x","„Öã„ÖÖ"],
      ["c","„Öã"], ["g","„Ñ±"], ["k","„Öã"], ["j","„Öà"], ["q","„Öã"],
      ["r","„Ñπ"], ["l","„Ñπ"], ["m","„ÖÅ"], ["n","„Ñ¥"], ["b","„ÖÇ"], ["p","„Öç"],
      ["d","„Ñ∑"], ["t","„Öå"], ["f","„Öç"], ["v","„ÖÇ"], ["h","„Öé"], ["s","„ÖÖ"], ["z","„Öà"], ["w","„Öá"],
    ];

    function tokenize(word) {
      let s = word.toLowerCase();
      const out = [];
      let i = 0;
      while (i < s.length) {
        const ch = s[i];
        if (ch === "'" || ch === "-") { i++; continue; }

        if (s[i] === "c" && (s[i+1] === "e" || s[i+1] === "i" || s[i+1] === "y")) {
          out.push({type:"C", val:"„ÖÖ"}); i += 1; continue;
        }

        let matched = false;

        for (const [pat, val] of VOWELS) {
          if (s.startsWith(pat, i)) { out.push({type:"V", val}); i += pat.length; matched = true; break; }
        }
        if (matched) continue;

        for (const [pat, val] of CONS) {
          if (s.startsWith(pat, i)) { out.push({type:"C", val}); i += pat.length; matched = true; break; }
        }
        if (matched) continue;

        i++;
      }
      return out;
    }

    function pickJung(vowelSyllables) {
      const map = [
        ["ÏïÑ","„Öè"], ["Ïï†","„Öê"], ["Ïïº","„Öë"], ["Ïòà","„Öñ"], ["Ïóê","„Öî"],
        ["Ïñ¥","„Öì"], ["Ïó¨","„Öï"],
        ["Ïò§","„Öó"], ["ÏôÄ","„Öò"], ["Ïôú","„Öô"], ["Ïô∏","„Öö"],
        ["Ïö∞","„Öú"], ["Ïõå","„Öù"], ["Ïõ®","„Öû"], ["ÏúÑ","„Öü"],
        ["Ïú†","„Ö†"], ["Ïúº","„Ö°"], ["Ïùò","„Ö¢"], ["Ïù¥","„Ö£"],
      ];
      for (const [k,v] of map) if (vowelSyllables.startsWith(k)) return v;
      return "„Öè";
    }

    function toJong(consonantJamo) {
      const last = consonantJamo.slice(-1);
      if (JONG.includes(last)) return last;
      const close = {"„Öç":"„ÖÇ","„Öã":"„Ñ±","„Öä":"„Öà","„Öå":"„Ñ∑","„ÖÜ":"„ÖÖ"};
      return (close[last] && JONG.includes(close[last])) ? close[last] : "";
    }

    function toCho(consonantJamo) {
      const first = consonantJamo[0];
      if (CHO.includes(first)) return first;
      const close = {"„Öç":"„ÖÇ","„Öã":"„Ñ±","„Öä":"„Öà","„Öå":"„Ñ∑","„ÖÜ":"„ÖÖ"};
      return (close[first] && CHO.includes(close[first])) ? close[first] : "„Öá";
    }

    function ruleBasedHangul(word) {
      const tokens = tokenize(word);
      if (!tokens.length) return "";
      let res = "";
      let i = 0;
      while (i < tokens.length) {
        let cho = "„Öá";
        if (tokens[i]?.type === "C") { cho = toCho(tokens[i].val); i++; }
        if (tokens[i]?.type !== "V") break;
        const jung = pickJung(tokens[i].val);
        i++;

        let jong = "";
        if (tokens[i]?.type === "C" && tokens[i+1]?.type !== "V") {
          jong = toJong(tokens[i].val);
          i++;
        }
        res += composeSyllable(cho, jung, jong);
      }
      return res;
    }

    // ------------------------------
    // Firestore helpers
    // ------------------------------
    async function getCanonical(nameKey) {
      if (canonicalCache.has(nameKey)) return canonicalCache.get(nameKey);
      try {
        const snap = await getDoc(doc(db, "canonical", nameKey));
        if (snap.exists()) {
          const data = snap.data();
          canonicalCache.set(nameKey, data);
          return data;
        }
      } catch {}
      return null;
    }

    async function fetchCommunitySuggestions(nameKey) {
      communityList.innerHTML = "";
      if (!nameKey) return;
      const q = query(
        collection(db, "suggestions"),
        where("nameKey", "==", nameKey),
        where("status", "in", ["approved", "pending"]),
        orderBy("score", "desc"),
        orderBy("reportCount", "asc"),
        orderBy("createdAt", "desc"),
        limit(8)
      );
      const snap = await getDocs(q);
      if (snap.empty) {
        communityList.innerHTML = `<div class="muted" style="margin-top:8px;">No suggestions yet.</div>`;
        return;
      }
      snap.forEach((docSnap) => {
        const s = docSnap.data();
        const row = document.createElement("div");
        row.className = "community-item";
        row.innerHTML = `
          <div>
            <div class="hangul">${escapeHtml(s.hangul)}</div>
            <div class="meta">
              <span class="mini-badge">Score ${s.score ?? 0}</span>
              <span class="mini-badge">Reports ${s.reportCount ?? 0}</span>
              <span class="mini-badge ${s.status === "approved" ? "badge-ok" : "badge-warn"}">${s.status === "approved" ? "Approved" : "Pending review"}</span>
            </div>
          </div>
          <div class="row" style="margin:0">
            <button class="btn" data-vote="up" data-id="${docSnap.id}">üëç</button>
            <button class="btn" data-vote="down" data-id="${docSnap.id}">üëé</button>
            <button class="btn" data-report="true" data-id="${docSnap.id}">Report</button>
          </div>
        `;
        communityList.appendChild(row);
      });
    }

    function isValidHangul(s) {
      return /[Í∞Ä-Ìû£]/.test(s || "");
    }

    function withinLimits(nameKey, hangul) {
      return nameKey.length >= 2 && nameKey.length <= 40 && hangul.length >= 1 && hangul.length <= 20;
    }

    function throttleSuggestion() {
      const last = Number(localStorage.getItem(LAST_SUGGESTION_KEY) || 0);
      const now = Date.now();
      if (now - last < 10000) return false;
      localStorage.setItem(LAST_SUGGESTION_KEY, String(now));
      return true;
    }

    async function submitSuggestion(nameKey, hangul) {
      if (!currentUser) { showToast("Signing in..."); return; }
      if (!isValidHangul(hangul)) { showToast("Hangul required"); return; }
      if (!withinLimits(nameKey, hangul)) { showToast("Length out of range"); return; }

      const canonical = await getCanonical(nameKey);
      if (canonical && canonical.hangulBest === hangul) {
        showToast("Already official");
        return;
      }

      if (!throttleSuggestion()) {
        showToast("Please wait 10s before submitting again");
        return;
      }

      // If duplicate suggestion exists, upvote it instead of creating a new doc.
      const dupQ = query(
        collection(db, "suggestions"),
        where("nameKey", "==", nameKey),
        where("hangul", "==", hangul),
        where("status", "in", ["pending", "approved"]),
        limit(1)
      );
      const dupSnap = await getDocs(dupQ);
      if (!dupSnap.empty) {
        const dupDoc = dupSnap.docs[0];
        await voteSuggestion(nameKey, dupDoc.id, 1);
        showToast("Voted existing suggestion");
        return;
      }

      const suggestionId = crypto.randomUUID();
      await setDoc(doc(db, "suggestions", suggestionId), {
        nameKey,
        hangul,
        status: "pending",
        votesUp: 1,
        votesDown: 0,
        score: 1,
        reportCount: 0,
        createdAt: serverTimestamp(),
        createdBy: currentUser.uid
      });

      await setDoc(doc(db, "votes", `${nameKey}_${currentUser.uid}`), {
        nameKey,
        suggestionId,
        vote: 1
      });

      showToast("Submitted for review");
      await fetchCommunitySuggestions(nameKey);
    }

    async function voteSuggestion(nameKey, suggestionId, vote) {
      if (!currentUser) { showToast("Signing in..."); return; }
      const voteId = `${nameKey}_${currentUser.uid}`;
      const voteRef = doc(db, "votes", voteId);
      await runTransaction(db, async (tx) => {
        const existingVote = await tx.get(voteRef);
        if (existingVote.exists()) return;
        const suggestionRef = doc(db, "suggestions", suggestionId);
        const suggestionSnap = await tx.get(suggestionRef);
        if (!suggestionSnap.exists()) return;

        const data = suggestionSnap.data();
        const up = (data.votesUp || 0) + (vote === 1 ? 1 : 0);
        const down = (data.votesDown || 0) + (vote === -1 ? 1 : 0);
        tx.update(suggestionRef, {
          votesUp: up,
          votesDown: down,
          score: up - down
        });
        tx.set(voteRef, { nameKey, suggestionId, vote });
      });
      await fetchCommunitySuggestions(nameKey);
    }

    async function reportSuggestion(nameKey, suggestionId) {
      if (!currentUser) { showToast("Signing in..."); return; }
      const reportId = `${suggestionId}_${currentUser.uid}`;
      const reportRef = doc(db, "reports", reportId);
      await runTransaction(db, async (tx) => {
        const existingReport = await tx.get(reportRef);
        if (existingReport.exists()) return;
        const suggestionRef = doc(db, "suggestions", suggestionId);
        const suggestionSnap = await tx.get(suggestionRef);
        if (!suggestionSnap.exists()) return;
        const data = suggestionSnap.data();
        tx.update(suggestionRef, { reportCount: (data.reportCount || 0) + 1 });
        tx.set(reportRef, { suggestionId, nameKey });
      });
      showToast("Reported");
      await fetchCommunitySuggestions(nameKey);
    }

    // ------------------------------
    // Lookup order: local > canonical > built-in > rule
    // ------------------------------
    async function lookupOneWord(wordLower) {
      const custom = loadCustomDict();
      if (custom[wordLower]) return { options: [custom[wordLower]], source: "custom" };

      const canonical = await getCanonical(wordLower);
      if (canonical?.hangulBest) {
        const alts = Array.isArray(canonical.alts) ? canonical.alts : [];
        return { options: [canonical.hangulBest, ...alts].filter(Boolean).slice(0,3), source: "canonical" };
      }

      if (BUILTIN_DICT.has(wordLower)) return { options: BUILTIN_DICT.get(wordLower), source: "builtin" };

      const base = ruleBasedHangul(wordLower);
      let thVariant = "";
      if (wordLower.includes("th")) thVariant = ruleBasedHangul(wordLower.replaceAll("th", "s"));
      const opts = [base, thVariant].filter(Boolean);
      return { options: [...new Set(opts)].slice(0, 3), source: "rule" };
    }

    function sourceLabel(src){
      if (src === "custom") return "Custom dictionary";
      if (src === "canonical") return "Canonical";
      if (src === "builtin") return "Built-in dictionary";
      return "Rule-based fallback";
    }

    async function renderResults(rawInput, wordResults, combinedOptions, combinedSource) {
      resultsEl.innerHTML = "";

      if (!combinedOptions.length) {
        resultsEl.innerHTML = `<div class="result"><div><div class="hangul">‚Äî</div><div class="meta">Couldn‚Äôt parse that. Please use letters only.</div></div></div>`;
        return;
      }

      combinedOptions.forEach((ko, idx) => {
        const el = document.createElement("div");
        el.className = "result";
        el.innerHTML = `
          <div>
            <div class="hangul">${escapeHtml(ko)}</div>
            <div class="meta">
              <span class="mini-badge">${idx === 0 ? "Recommended" : "Alternative"}</span>
              <span class="mini-badge">${escapeHtml(sourceLabel(combinedSource))}</span>
            </div>
          </div>
          <div class="row" style="margin:0">
            <button class="btn green" style="padding:10px 12px;border-radius:14px">Copy</button>
            <button class="btn" style="padding:10px 12px;border-radius:14px">Submit suggestion (reviewed before publication)</button>
          </div>
        `;
        const [copyBtn, fixBtn] = el.querySelectorAll("button");
        copyBtn.addEventListener("click", () => copyText(ko));
        fixBtn.addEventListener("click", () => setSuggestionFromOutput(rawInput, ko));
        resultsEl.appendChild(el);
      });

      const debug = document.createElement("div");
      debug.className = "muted";
      debug.style.marginTop = "8px";
      debug.innerHTML = wordResults.map(wr => {
        const s = wr.source === "custom" ? "custom" : (wr.source === "canonical" ? "canonical" : (wr.source === "builtin" ? "dict" : "rule"));
        return `${escapeHtml(wr.word)} <span style="opacity:.7">(${s})</span>`;
      }).join(" ¬∑ ");
      resultsEl.appendChild(debug);
    }

    async function convert() {
      const raw = nameInput.value.trim();
      if (!raw) { resultsEl.innerHTML = ""; return; }

      const cleaned = raw
        .replace(/[^a-zA-Z\s'-]/g, "")
        .replace(/\s+/g, " ")
        .trim();

      if (!cleaned) { resultsEl.innerHTML = ""; return; }

      const words = cleaned.split(" ").map(w => w.trim()).filter(Boolean);
      const wordResults = [];
      for (const w of words) {
        const key = normalizeEnglishKey(w);
        const res = await lookupOneWord(key);
        wordResults.push({ word: w, key, options: res.options, source: res.source });
      }

      const combined = [];
      for (let i = 0; i < 3; i++) {
        const parts = wordResults.map(wr => wr.options[i] || wr.options[0]).filter(Boolean);
        if (parts.length) combined.push(parts.join(" "));
      }
      const combinedOptions = [...new Set(combined)].slice(0, 3);

      const anyCustom = wordResults.some(w => w.source === "custom");
      const anyCanonical = wordResults.some(w => w.source === "canonical");
      const allBuiltin = wordResults.every(w => w.source === "builtin");
      const combinedSource = anyCustom ? "custom" : (anyCanonical ? "canonical" : (allBuiltin ? "builtin" : "rule"));

      await renderResults(raw, wordResults, combinedOptions, combinedSource);

      suggestKey.value = normalizeEnglishKey(raw);
      if (!suggestHangul.value) suggestHangul.value = combinedOptions[0] || "";

      const firstKey = wordResults[0]?.key || "";
      if (firstKey) {
        fetchCommunitySuggestions(firstKey).catch(() => {});
      }
    }

    $("#convertBtn").addEventListener("click", convert);
    nameInput.addEventListener("keydown", (e) => { if (e.key === "Enter") convert(); });

    function setSuggestionFromOutput(en, ko) {
      suggestKey.value = normalizeEnglishKey(en);
      suggestHangul.value = ko;
      document.getElementById("community").scrollIntoView({ behavior: "smooth", block: "start" });
    }

    submitSuggestionBtn.addEventListener("click", () => {
      const key = normalizeEnglishKey(suggestKey.value || nameInput.value);
      const hangul = normalizeHangulValue(suggestHangul.value);
      if (!key || key.length < 2) { showToast("Enter an English name"); return; }
      if (!hangul) { showToast("Enter a Hangul spelling"); return; }
      submitSuggestion(key, hangul).catch(() => showToast("Failed to submit"));
    });

    communityList.addEventListener("click", (e) => {
      const btn = e.target.closest("button");
      if (!btn) return;
      const suggestionId = btn.getAttribute("data-id");
      if (!suggestionId) return;
      const nameKey = normalizeEnglishKey(suggestKey.value || nameInput.value);
      if (btn.getAttribute("data-vote") === "up") {
        voteSuggestion(nameKey, suggestionId, 1).catch(() => showToast("Vote failed"));
      } else if (btn.getAttribute("data-vote") === "down") {
        voteSuggestion(nameKey, suggestionId, -1).catch(() => showToast("Vote failed"));
      } else if (btn.getAttribute("data-report")) {
        reportSuggestion(nameKey, suggestionId).catch(() => showToast("Report failed"));
      }
    });

    nameInput.focus();
  </script>
</body>
</html>
