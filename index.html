<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="google-adsense-account" content="ca-pub-7713287823701747">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Name → Hangul</title>
  <meta name="description" content="Write your English name in Hangul. Dictionary-first accuracy + smart fallback. Browser-only."/>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7713287823701747" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="wrap">
    <header class="reveal">
      <div class="brand">
        <div class="mark" aria-hidden="true"></div>
        <div>
          <h1>Name → Hangul</h1>
          <p>English name → natural Hangul spelling · browser-only</p>
        </div>
      </div>
      <div class="top-actions">
        <div class="pill" id="clearBtn" title="Clear">
          <span aria-hidden="true">⌫</span><span>Reset</span>
        </div>
      </div>
    </header>

    <nav class="nav reveal delay-1" aria-label="Page">
      <a href="#tool">Tool</a>
      <a href="#how">How it works</a>
      <a href="#examples">Examples</a>
      <a href="#quality">Quality & intent</a>
      <a href="#faq">FAQ</a>
      <a href="#privacy">Privacy</a>
      <a href="#contact">Contact</a>
      <a href="privacy.html">Privacy Policy</a>
      <a href="terms.html">Terms</a>
      <a href="about.html">About</a>
    </nav>

    <section class="hero reveal delay-2">
      <h2 class="headline">Write your name in Hangul</h2>
      <p class="subhead">
        Dictionary-first for accuracy. If something looks wrong, save a correction once —
        your browser will remember it. This site is designed for English speakers who want
        a clean, readable Hangul spelling for personal or creative use.
      </p>
    </section>

    <section id="tool" class="grid">
      <section class="card reveal delay-3">
        <div class="inner">
          <div class="badge">English-only · No server · No AI tokens</div>

          <div class="row">
            <div class="field" role="group" aria-label="Name input">
              <div class="icon" aria-hidden="true">Aa</div>
              <input id="nameInput" placeholder="e.g., Jacob / Jason / Michael" autocomplete="off" />
            </div>
            <button class="btn primary" id="convertBtn">Convert</button>
          </div>

          <div class="results" id="results"></div>

          <div class="hint">
            Tip: click <b>Fix</b> on a result to pre-fill the right panel.
          </div>
        </div>
      </section>

      <aside class="card reveal delay-4" id="dictionary">
        <div class="inner">
          <div class="panel-title">
            <b>Fix a name (dictionary)</b>
            <span class="muted" id="dictStatus"></span>
          </div>
          <div class="muted">If Google Translate is “right”, just save that spelling here.</div>

          <div class="row" style="margin-top:10px">
            <div class="field" style="flex:1 1 240px">
              <div class="icon" aria-hidden="true">EN</div>
              <input id="fixEn" placeholder="English (e.g., Jacob)" autocomplete="off" />
            </div>
            <div class="field" style="flex:1 1 240px">
              <div class="icon" aria-hidden="true">가</div>
              <input id="fixKo" placeholder="Hangul (e.g., 제이콥)" autocomplete="off" />
            </div>
          </div>

          <div class="row">
            <button class="btn green" id="saveFixBtn">Save</button>
            <button class="btn danger" id="deleteFixBtn">Delete</button>
            <button class="btn" id="exportDictBtn">Copy dictionary</button>
            <button class="btn" id="resetDictBtn" title="Remove all your custom fixes">Reset custom</button>
          </div>

          <div class="hint" style="margin-top:12px">
            Your fixes are stored only in this browser (localStorage).
          </div>
        </div>
      </aside>
    </section>

    <section id="how" class="section reveal delay-2">
      <div class="section-head">
        <h3>How it works</h3>
        <span>Accuracy first</span>
      </div>
      <p class="text">
        The converter follows a simple priority order to reduce weird spellings. First it checks a
        built-in dictionary of common names. If no match exists, it applies a rule-based fallback
        that approximates English pronunciation into Hangul syllables. You can override any result
        by saving a custom spelling, which always wins.
      </p>
      <div class="card-grid">
        <div class="mini-card">
          <b>1) Dictionary-first</b>
          <p class="text">Common names are mapped to the most natural Hangul spelling.</p>
        </div>
        <div class="mini-card">
          <b>2) Rule-based fallback</b>
          <p class="text">If a name is not found, the converter builds syllables from vowel/consonant patterns.</p>
        </div>
        <div class="mini-card">
          <b>3) Custom fixes</b>
          <p class="text">Save your own spelling once; your browser remembers it.</p>
        </div>
      </div>
    </section>

    <section id="examples" class="section reveal delay-3">
      <div class="section-head">
        <h3>Example conversions</h3>
        <span>Realistic output</span>
      </div>
      <table class="table" aria-label="Example conversions">
        <thead>
          <tr>
            <th>English</th>
            <th>Hangul (recommended)</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Jacob</td>
            <td>제이콥</td>
            <td>Dictionary match</td>
          </tr>
          <tr>
            <td>Thomas</td>
            <td>토머스</td>
            <td>Dictionary match</td>
          </tr>
          <tr>
            <td>Charlie</td>
            <td>찰리</td>
            <td>Dictionary match</td>
          </tr>
          <tr>
            <td>Avery</td>
            <td>에이브리</td>
            <td>Rule-based fallback</td>
          </tr>
          <tr>
            <td>Brooklyn</td>
            <td>브루클린</td>
            <td>Rule-based fallback</td>
          </tr>
        </tbody>
      </table>
      <p class="text">Names vary by preference. If you want a different spelling, save it in the custom dictionary.</p>
    </section>

    <section id="quality" class="section reveal delay-4">
      <div class="section-head">
        <h3>Quality & intent</h3>
        <span>User-first content</span>
      </div>
      <p class="text">
        This page exists to deliver a specific, useful service: converting English names into Hangul
        in a way that feels natural to Korean readers. The content is original, focused, and built
        to be easy to navigate. There are no empty pages, no keyword stuffing, and no deceptive flows.
      </p>
      <div class="card-grid">
        <div class="mini-card">
          <b>Clear purpose</b>
          <p class="text">One focused tool with direct, practical output.</p>
        </div>
        <div class="mini-card">
          <b>Readable structure</b>
          <p class="text">Sections explain how it works, examples, and limitations.</p>
        </div>
        <div class="mini-card">
          <b>Honest limitations</b>
          <p class="text">Spellings vary; you can correct and save your preference.</p>
        </div>
      </div>
    </section>

    <section id="faq" class="section reveal delay-5">
      <div class="section-head">
        <h3>FAQ</h3>
        <span>Quick answers</span>
      </div>
      <div class="faq">
        <div class="faq-item">
          <h4>Is this an official romanization tool?</h4>
          <p>No. This is a practical name spelling helper based on common usage and a simple rule fallback.</p>
        </div>
        <div class="faq-item">
          <h4>Will the result be “correct”?</h4>
          <p>There is no single official spelling for many names. If you prefer a different spelling, save it.</p>
        </div>
        <div class="faq-item">
          <h4>Do you store my name?</h4>
          <p>No. Everything runs in your browser. Only your custom dictionary is saved locally.</p>
        </div>
        <div class="faq-item">
          <h4>Can I use this on mobile?</h4>
          <p>Yes. The site is responsive and runs entirely in the browser.</p>
        </div>
      </div>
    </section>

    <section id="privacy" class="section reveal delay-3">
      <div class="section-head">
        <h3>Privacy</h3>
        <span>No server</span>
      </div>
      <p class="text">
        This tool does not send your input to a server. The converter runs on-device. If you save a
        custom spelling, it is stored only in your browser via localStorage. For details, read the
        full privacy policy page.
      </p>
    </section>

    <section id="contact" class="section reveal delay-4">
      <div class="section-head">
        <h3>Contact</h3>
        <span>Feedback welcome</span>
      </div>
      <p class="text">
        If you find a name that looks wrong or want to suggest improvements, please use the contact
        page and include the English spelling and your preferred Hangul output. You can also reach
        us at <b>goodhywon@gmail.com</b>.
      </p>
    </section>

    <footer class="reveal delay-5">
      © <span id="year"></span> Name → Hangul · Privacy-friendly (localStorage only) ·
      Contact: <b>goodhywon@gmail.com</b> ·
      <a href="privacy.html">Privacy</a> · <a href="terms.html">Terms</a> · <a href="contact.html">Contact</a>
    </footer>
  </div>

  <div class="toast" id="toast">Copied!</div>

  <script>
    // ------------------------------
    // Storage keys
    // ------------------------------
    const THEME_KEY = "nh_theme";
    const CUSTOM_DICT_KEY = "nh_custom_dict";

    // ------------------------------
    // Built-in dictionary (seed)
    // ------------------------------
    const BUILTIN_DICT = new Map([
      ["jacob", ["제이콥"]],
      ["jason", ["제이슨"]],
      ["mason", ["메이슨"]],
      ["jackson", ["잭슨","재커슨"]],
      ["michael", ["마이클"]],
      ["william", ["윌리엄","윌리암"]],
      ["thomas", ["토머스","토마스"]],
      ["james", ["제임스"]],
      ["andrew", ["앤드루"]],
      ["henry", ["헨리"]],
      ["george", ["조지"]],
      ["david", ["데이비드"]],
      ["john", ["존"]],
      ["noah", ["노아"]],
      ["isaac", ["아이작","이삭"]],
      ["benjamin", ["벤자민"]],
      ["alexander", ["알렉산더","알렉산더르"]],
      ["charlie", ["찰리"]],
      ["harry", ["해리"]],
      ["leo", ["레오"]],
      ["liam", ["리암"]],
      ["oliver", ["올리버"]],
      ["jack", ["잭"]],
    ]);

    // ------------------------------
    // DOM
    // ------------------------------
    const $ = (s) => document.querySelector(s);
    const nameInput = $("#nameInput");
    const resultsEl = $("#results");
    const toast = $("#toast");

    const fixEn = $("#fixEn");
    const fixKo = $("#fixKo");
    const dictStatus = $("#dictStatus");

    $("#year").textContent = new Date().getFullYear();

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }

    function showToast(msg="Copied!") {
      toast.textContent = msg;
      toast.classList.add("show");
      setTimeout(() => toast.classList.remove("show"), 900);
    }

    async function copyText(t) {
      try {
        await navigator.clipboard.writeText(t);
        showToast("Copied!");
      } catch {
        const ta = document.createElement("textarea");
        ta.value = t;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
        showToast("Copied!");
      }
    }

    $("#clearBtn").addEventListener("click", () => {
      nameInput.value = "";
      resultsEl.innerHTML = "";
      nameInput.focus();
    });

    // ------------------------------
    // Custom dictionary (highest priority)
    // ------------------------------
    function loadCustomDict() {
      try {
        const obj = JSON.parse(localStorage.getItem(CUSTOM_DICT_KEY) || "{}");
        if (obj && typeof obj === "object") return obj;
      } catch {}
      return {};
    }

    function saveCustomDict(obj) {
      localStorage.setItem(CUSTOM_DICT_KEY, JSON.stringify(obj));
    }

    function normalizeEnglishKey(s) {
      return (s || "")
        .trim()
        .toLowerCase()
        .replace(/[^a-z\s'-]/g, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    function normalizeHangulValue(s) {
      return (s || "").trim().replace(/\s+/g, " ").trim();
    }

    function updateDictStatus() {
      const d = loadCustomDict();
      dictStatus.textContent = `${Object.keys(d).length} custom fixes`;
    }

    // ------------------------------
    // Rule-based fallback
    // ------------------------------
    const CHO  = ["ㄱ","ㄲ","ㄴ","ㄷ","ㄸ","ㄹ","ㅁ","ㅂ","ㅃ","ㅅ","ㅆ","ㅇ","ㅈ","ㅉ","ㅊ","ㅋ","ㅌ","ㅍ","ㅎ"];
    const JUNG = ["ㅏ","ㅐ","ㅑ","ㅒ","ㅓ","ㅔ","ㅕ","ㅖ","ㅗ","ㅘ","ㅙ","ㅚ","ㅛ","ㅜ","ㅝ","ㅞ","ㅟ","ㅠ","ㅡ","ㅢ","ㅣ"];
    const JONG = ["", "ㄱ","ㄲ","ㄳ","ㄴ","ㄵ","ㄶ","ㄷ","ㄹ","ㄺ","ㄻ","ㄼ","ㄽ","ㄾ","ㄿ","ㅀ","ㅁ","ㅂ","ㅄ","ㅅ","ㅆ","ㅇ","ㅈ","ㅊ","ㅋ","ㅌ","ㅍ","ㅎ"];
    const choIndex  = Object.fromEntries(CHO.map((c,i)=>[c,i]));
    const jungIndex = Object.fromEntries(JUNG.map((c,i)=>[c,i]));
    const jongIndex = Object.fromEntries(JONG.map((c,i)=>[c,i]));

    function composeSyllable(cho, jung, jong="") {
      if (!(cho in choIndex)) cho = "ㅇ";
      if (!(jung in jungIndex)) jung = "ㅏ";
      if (!(jong in jongIndex)) jong = "";
      const base = 0xAC00;
      const code = base + (choIndex[cho] * 21 * 28) + (jungIndex[jung] * 28) + jongIndex[jong];
      return String.fromCharCode(code);
    }

    const VOWELS = [
      ["eigh","에이"], ["igh","아이"],
      ["eau","오"], ["ieu","유"],
      ["ai","에이"], ["ay","에이"],
      ["ea","이"], ["ee","이"], ["ie","이"], ["ei","이"],
      ["oo","우"], ["ow","아우"], ["ou","아우"],
      ["au","오"], ["aw","오"],
      ["oi","오이"], ["oy","오이"],
      ["oa","오"], ["oe","오"],
      ["a","아"], ["e","에"], ["i","이"], ["o","오"], ["u","우"], ["y","이"]
    ];

    const CONS = [
      ["tch","ㅊ"], ["ch","ㅊ"], ["sh","ㅅ"], ["ph","ㅍ"],
      ["th","ㅌ"], ["ck","ㅋ"], ["ng","ㅇ"], ["qu","ㅋ"], ["wh","ㅎ"],
      ["kn","ㄴ"], ["wr","ㄹ"], ["ps","ㅅ"], ["x","ㅋㅅ"],
      ["c","ㅋ"], ["g","ㄱ"], ["k","ㅋ"], ["j","ㅈ"], ["q","ㅋ"],
      ["r","ㄹ"], ["l","ㄹ"], ["m","ㅁ"], ["n","ㄴ"], ["b","ㅂ"], ["p","ㅍ"],
      ["d","ㄷ"], ["t","ㅌ"], ["f","ㅍ"], ["v","ㅂ"], ["h","ㅎ"], ["s","ㅅ"], ["z","ㅈ"], ["w","ㅇ"],
    ];

    function tokenize(word) {
      let s = word.toLowerCase();
      const out = [];
      let i = 0;
      while (i < s.length) {
        const ch = s[i];
        if (ch === "'" || ch === "-") { i++; continue; }

        if (s[i] === "c" && (s[i+1] === "e" || s[i+1] === "i" || s[i+1] === "y")) {
          out.push({type:"C", val:"ㅅ"}); i += 1; continue;
        }

        let matched = false;

        for (const [pat, val] of VOWELS) {
          if (s.startsWith(pat, i)) { out.push({type:"V", val}); i += pat.length; matched = true; break; }
        }
        if (matched) continue;

        for (const [pat, val] of CONS) {
          if (s.startsWith(pat, i)) { out.push({type:"C", val}); i += pat.length; matched = true; break; }
        }
        if (matched) continue;

        i++;
      }
      return out;
    }

    function pickJung(vowelSyllables) {
      const map = [
        ["아","ㅏ"], ["애","ㅐ"], ["야","ㅑ"], ["예","ㅖ"], ["에","ㅔ"],
        ["어","ㅓ"], ["여","ㅕ"],
        ["오","ㅗ"], ["와","ㅘ"], ["왜","ㅙ"], ["외","ㅚ"],
        ["우","ㅜ"], ["워","ㅝ"], ["웨","ㅞ"], ["위","ㅟ"],
        ["유","ㅠ"], ["으","ㅡ"], ["의","ㅢ"], ["이","ㅣ"],
      ];
      for (const [k,v] of map) if (vowelSyllables.startsWith(k)) return v;
      return "ㅏ";
    }

    function toJong(consonantJamo) {
      const last = consonantJamo.slice(-1);
      if (JONG.includes(last)) return last;
      const close = {"ㅍ":"ㅂ","ㅋ":"ㄱ","ㅊ":"ㅈ","ㅌ":"ㄷ","ㅆ":"ㅅ"};
      return (close[last] && JONG.includes(close[last])) ? close[last] : "";
    }

    function toCho(consonantJamo) {
      const first = consonantJamo[0];
      if (CHO.includes(first)) return first;
      const close = {"ㅍ":"ㅂ","ㅋ":"ㄱ","ㅊ":"ㅈ","ㅌ":"ㄷ","ㅆ":"ㅅ"};
      return (close[first] && CHO.includes(close[first])) ? close[first] : "ㅇ";
    }

    function ruleBasedHangul(word) {
      const tokens = tokenize(word);
      if (!tokens.length) return "";
      let res = "";
      let i = 0;
      while (i < tokens.length) {
        let cho = "ㅇ";
        if (tokens[i]?.type === "C") { cho = toCho(tokens[i].val); i++; }
        if (tokens[i]?.type !== "V") break;
        const jung = pickJung(tokens[i].val);
        i++;

        let jong = "";
        if (tokens[i]?.type === "C" && tokens[i+1]?.type !== "V") {
          jong = toJong(tokens[i].val);
          i++;
        }
        res += composeSyllable(cho, jung, jong);
      }
      return res;
    }

    function lookupOneWord(wordLower) {
      const custom = loadCustomDict();
      if (custom[wordLower]) return { options: [custom[wordLower]], source: "custom" };
      if (BUILTIN_DICT.has(wordLower)) return { options: BUILTIN_DICT.get(wordLower), source: "builtin" };

      const base = ruleBasedHangul(wordLower);
      let thVariant = "";
      if (wordLower.includes("th")) thVariant = ruleBasedHangul(wordLower.replaceAll("th", "s"));
      const opts = [base, thVariant].filter(Boolean);
      return { options: [...new Set(opts)].slice(0, 3), source: "rule" };
    }

    function sourceLabel(src){
      if (src === "custom") return "Custom dictionary";
      if (src === "builtin") return "Built-in dictionary";
      return "Rule-based fallback";
    }

    function renderResults(rawInput, wordResults, combinedOptions, combinedSource) {
      resultsEl.innerHTML = "";

      if (!combinedOptions.length) {
        resultsEl.innerHTML = `<div class="result"><div><div class="hangul">—</div><div class="meta">Couldn’t parse that. Please use letters only.</div></div></div>`;
        return;
      }

      combinedOptions.forEach((ko, idx) => {
        const el = document.createElement("div");
        el.className = "result";
        el.innerHTML = `
          <div>
            <div class="hangul">${escapeHtml(ko)}</div>
            <div class="meta">
              <span class="mini-badge">${idx === 0 ? "Recommended" : "Alternative"}</span>
              <span class="mini-badge">${escapeHtml(sourceLabel(combinedSource))}</span>
            </div>
          </div>
          <div class="row" style="margin:0">
            <button class="btn green" style="padding:10px 12px;border-radius:14px">Copy</button>
            <button class="btn" style="padding:10px 12px;border-radius:14px">Fix</button>
          </div>
        `;
        const [copyBtn, fixBtn] = el.querySelectorAll("button");
        copyBtn.addEventListener("click", () => copyText(ko));
        fixBtn.addEventListener("click", () => setFixBoxesFromInputOutput(rawInput, ko));
        resultsEl.appendChild(el);
      });

      const debug = document.createElement("div");
      debug.className = "muted";
      debug.style.marginTop = "8px";
      debug.innerHTML = wordResults.map(wr => {
        const s = wr.source === "custom" ? "custom" : (wr.source === "builtin" ? "dict" : "rule");
        return `${escapeHtml(wr.word)} <span style="opacity:.7">(${s})</span>`;
      }).join(" · ");
      resultsEl.appendChild(debug);
    }

    function convert() {
      const raw = nameInput.value.trim();
      if (!raw) { resultsEl.innerHTML = ""; return; }

      const cleaned = raw
        .replace(/[^a-zA-Z\s'-]/g, "")
        .replace(/\s+/g, " ")
        .trim();

      if (!cleaned) { resultsEl.innerHTML = ""; return; }

      const words = cleaned.split(" ").map(w => w.trim()).filter(Boolean);
      const wordResults = words.map(w => {
        const key = normalizeEnglishKey(w);
        const res = lookupOneWord(key);
        return { word: w, key, options: res.options, source: res.source };
      });

      const combined = [];
      for (let i = 0; i < 3; i++) {
        const parts = wordResults.map(wr => wr.options[i] || wr.options[0]).filter(Boolean);
        if (parts.length) combined.push(parts.join(" "));
      }
      const combinedOptions = [...new Set(combined)].slice(0, 3);

      const anyCustom = wordResults.some(w => w.source === "custom");
      const allBuiltin = wordResults.every(w => w.source === "builtin");
      const combinedSource = anyCustom ? "custom" : (allBuiltin ? "builtin" : "rule");

      renderResults(raw, wordResults, combinedOptions, combinedSource);

      fixEn.value = normalizeEnglishKey(raw);
      if (!fixKo.value) fixKo.value = combinedOptions[0] || "";
      updateDictStatus();
    }

    $("#convertBtn").addEventListener("click", convert);
    nameInput.addEventListener("keydown", (e) => { if (e.key === "Enter") convert(); });

    $("#saveFixBtn").addEventListener("click", () => {
      const en = normalizeEnglishKey(fixEn.value);
      const ko = normalizeHangulValue(fixKo.value);

      if (!en || en.length < 2) { showToast("Enter an English name"); return; }
      if (!ko || !/[가-힣]/.test(ko)) { showToast("Enter a Hangul spelling"); return; }

      const d = loadCustomDict();
      d[en] = ko;
      saveCustomDict(d);

      updateDictStatus();
      showToast("Saved!");
      nameInput.value = en;
      convert();
    });

    $("#deleteFixBtn").addEventListener("click", () => {
      const en = normalizeEnglishKey(fixEn.value);
      if (!en) { showToast("Enter the English name"); return; }

      const d = loadCustomDict();
      if (d[en]) {
        delete d[en];
        saveCustomDict(d);
        updateDictStatus();
        showToast("Deleted!");
      } else {
        showToast("No custom entry");
      }
      convert();
    });

    $("#exportDictBtn").addEventListener("click", async () => {
      const d = loadCustomDict();
      const lines = Object.entries(d)
        .sort((a,b)=>a[0].localeCompare(b[0]))
        .map(([k,v]) => `${k}\t${v}`);
      await copyText(lines.join("\n") || "(empty)");
    });

    $("#resetDictBtn").addEventListener("click", () => {
      localStorage.removeItem(CUSTOM_DICT_KEY);
      updateDictStatus();
      showToast("Reset custom fixes!");
      convert();
    });

    function setFixBoxesFromInputOutput(en, ko) {
      fixEn.value = normalizeEnglishKey(en);
      fixKo.value = ko;
    }

    updateDictStatus();
    nameInput.focus();
    $("#year").textContent = new Date().getFullYear();
  </script>
</body>
</html>
