<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="google-adsense-account" content="ca-pub-7713287823701747">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Name â†’ Hangul</title>
  <meta name="description" content="Write your English name in Hangul. Dictionary-first accuracy + smart fallback. Browser-only."/>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7713287823701747" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="wrap">
    <header class="reveal">
      <div class="brand">
        <div class="mark" aria-hidden="true"></div>
        <div>
          <h1>Name â†’ Hangul</h1>
          <p>English name â†’ natural Hangul spelling</p>
        </div>
      </div>
      <div class="top-actions">
        <div class="pill" id="clearBtn" title="Clear">
          <span aria-hidden="true">âŒ«</span><span>Reset</span>
        </div>
      </div>
    </header>

    <nav class="nav reveal delay-1" aria-label="Page">
      <a href="#tool">Tool</a>
      <a href="#tool">Convert</a>
      <a href="#community">Community</a>
      <a href="#about">About</a>
      <a href="#privacy">Privacy</a>
      <a href="#contact">Contact</a>
      <a href="privacy.html">Privacy Policy</a>
      <a href="terms.html">Terms</a>
      <a href="about.html">About</a>
    </nav>

    <section class="hero reveal delay-2">
      <h2 class="headline">Write your name in Hangul</h2>
      <p class="subhead">
        A calm, culture-forward tool to turn English names into elegant Hangul. Try it, tweak it,
        and share your best spelling with the community.
      </p>
    </section>

    <section id="tool" class="grid">
      <section class="card reveal delay-3">
        <div class="inner">
          <div class="badge">English-only Â· Community reviewed</div>

          <div class="row">
            <div class="field" role="group" aria-label="Name input">
              <div class="icon" aria-hidden="true">Aa</div>
              <input id="nameInput" placeholder="e.g., Jacob / Jason / Michael" autocomplete="off" />
            </div>
            <button class="btn primary" id="convertBtn">Convert</button>
            <button class="btn" id="randomBtn" type="button">Surprise me</button>
          </div>

          <div class="results" id="results"></div>

          <div class="hint">
            Tip: click <b>Submit suggestion</b> to propose a better spelling.
          </div>
        </div>
      </section>
    </section>

    <section id="community" class="section reveal delay-2">
      <div class="section-head">
        <h3>Community suggestions</h3>
        <span>Reviewed</span>
      </div>
      <p class="text">Community suggestions are reviewed before becoming official.</p>
      <div class="row" style="margin-top:10px;">
        <div class="field" style="flex:1 1 240px">
          <div class="icon" aria-hidden="true">EN</div>
          <input id="suggestKey" placeholder="Name key" autocomplete="off" />
        </div>
        <div class="field" style="flex:1 1 240px">
          <div class="icon" aria-hidden="true">ê°€</div>
          <input id="suggestHangul" placeholder="Suggested Hangul" autocomplete="off" />
        </div>
      </div>
      <div class="row" style="margin-top:10px;">
        <button class="btn" id="submitSuggestionBtn">Submit suggestion (reviewed before publication)</button>
      </div>
      <div class="community-list" id="communityList"></div>
    </section>

    <section id="about" class="section reveal delay-3">
      <div class="section-head">
        <h3>About</h3>
        <span>Korean-first feel</span>
      </div>
      <p class="text">
        We blend a curated dictionary with pronunciation rules, then let the community refine the best spelling.
        The goal is a Hangul result that feels natural to read and write.
      </p>
    </section>

    <section id="privacy" class="section reveal delay-4">
      <div class="section-head">
        <h3>Privacy</h3>
        <span>Transparency</span>
      </div>
      <p class="text">
        For details about data handling and advertising, read the full privacy policy page.
      </p>
    </section>

    <section id="contact" class="section reveal delay-5">
      <div class="section-head">
        <h3>Contact</h3>
        <span>Feedback welcome</span>
      </div>
      <p class="text">
        If you find a name that looks wrong or want to suggest improvements, please use the contact
        page and include the English spelling and your preferred Hangul output. You can also reach
        us at <b>goodhywon@gmail.com</b>.
      </p>
    </section>

    <footer class="reveal delay-5">
      Â© <span id="year"></span> Name â†’ Hangul Â· Privacy-friendly (localStorage only) Â·
      Contact: <b>goodhywon@gmail.com</b> Â·
      <a href="privacy.html">Privacy</a> Â· <a href="terms.html">Terms</a> Â· <a href="contact.html">Contact</a>
    </footer>
  </div>

  <div class="toast" id="toast">Copied!</div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
    import {
      getFirestore, doc, getDoc, setDoc, updateDoc, serverTimestamp,
      collection, query, where, orderBy, limit, getDocs, runTransaction, enableIndexedDbPersistence
    } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";

    // ------------------------------
    // Firebase config (replace with your project values)
    // ------------------------------
    const firebaseConfig = {
      apiKey: "AIzaSyBU-bWMdsusXQ3Uc_vxOvRlpp2FsNrtszc",
      authDomain: "productbuilder-week1-fccc8.firebaseapp.com",
      projectId: "productbuilder-week1-fccc8",
      storageBucket: "productbuilder-week1-fccc8.firebasestorage.app",
      messagingSenderId: "652260101175",
      appId: "1:652260101175:web:d905f7b2ff34e0a96043b2"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    enableIndexedDbPersistence(db).catch(() => {});

    // ------------------------------
    // Storage keys
    // ------------------------------
    const CUSTOM_DICT_KEY = "nh_custom_dict";
    const LAST_SUGGESTION_KEY = "nh_last_suggestion_ts";

    // ------------------------------
    // Built-in dictionary (seed)
    // ------------------------------
    const BUILTIN_DICT = new Map([
      ["jacob", ["ì œì´ì½¥"]],
      ["jason", ["ì œì´ìŠ¨"]],
      ["mason", ["ë©”ì´ìŠ¨"]],
      ["jackson", ["ì­ìŠ¨","ì¬ì»¤ìŠ¨"]],
      ["michael", ["ë§ˆì´í´"]],
      ["william", ["ìœŒë¦¬ì—„","ìœŒë¦¬ì•”"]],
      ["thomas", ["í† ë¨¸ìŠ¤","í† ë§ˆìŠ¤"]],
      ["james", ["ì œì„ìŠ¤"]],
      ["andrew", ["ì•¤ë“œë£¨"]],
      ["henry", ["í—¨ë¦¬"]],
      ["george", ["ì¡°ì§€"]],
      ["david", ["ë°ì´ë¹„ë“œ"]],
      ["john", ["ì¡´"]],
      ["noah", ["ë…¸ì•„"]],
      ["isaac", ["ì•„ì´ì‘","ì´ì‚­"]],
      ["benjamin", ["ë²¤ìë¯¼"]],
      ["alexander", ["ì•Œë ‰ì‚°ë”","ì•Œë ‰ì‚°ë”ë¥´"]],
      ["charlie", ["ì°°ë¦¬"]],
      ["harry", ["í•´ë¦¬"]],
      ["leo", ["ë ˆì˜¤"]],
      ["liam", ["ë¦¬ì•”"]],
      ["oliver", ["ì˜¬ë¦¬ë²„"]],
      ["jack", ["ì­"]]
    ]);

    // ------------------------------
    // DOM
    // ------------------------------
    const $ = (s) => document.querySelector(s);
    const nameInput = $("#nameInput");
    const resultsEl = $("#results");
    const toast = $("#toast");
    const communityList = $("#communityList");
    const randomBtn = $("#randomBtn");

    const suggestKey = $("#suggestKey");
    const suggestHangul = $("#suggestHangul");
    const submitSuggestionBtn = $("#submitSuggestionBtn");

    $("#year").textContent = new Date().getFullYear();

    let currentUser = null;
    let authReadyResolve;
    const authReady = new Promise((resolve) => { authReadyResolve = resolve; });
    let lastNameKey = "";
    let lastRecommended = "";
    let lastSource = "";
    let canonicalCache = new Map();

    onAuthStateChanged(auth, (user) => {
      currentUser = user;
      if (user) authReadyResolve?.();
      if (!user) {
        signInAnonymously(auth).catch(() => {});
      }
    });

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }

    function showToast(msg="Copied!") {
      toast.textContent = msg;
      toast.classList.add("show");
      setTimeout(() => toast.classList.remove("show"), 900);
    }

    async function copyText(t) {
      try {
        await navigator.clipboard.writeText(t);
        showToast("Copied!");
      } catch {
        const ta = document.createElement("textarea");
        ta.value = t;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
        showToast("Copied!");
      }
    }

    $("#clearBtn").addEventListener("click", () => {
      nameInput.value = "";
      resultsEl.innerHTML = "";
      communityList.innerHTML = "";
      suggestKey.value = "";
      suggestHangul.value = "";
      nameInput.focus();
    });

    const RANDOM_NAMES = [
      "Jacob", "Jason", "Michael", "Emily", "Sophia", "Noah", "Oliver", "Mia",
      "Ethan", "Ava", "Lucas", "Liam", "Harper", "Mason", "Henry", "Chloe"
    ];

    randomBtn.addEventListener("click", () => {
      const pick = RANDOM_NAMES[Math.floor(Math.random() * RANDOM_NAMES.length)];
      nameInput.value = pick;
      convert();
    });

    // ------------------------------
    // Custom dictionary (highest priority)
    // ------------------------------
    function loadCustomDict() {
      try {
        const obj = JSON.parse(localStorage.getItem(CUSTOM_DICT_KEY) || "{}");
        if (obj && typeof obj === "object") return obj;
      } catch {}
      return {};
    }


    function normalizeEnglishKey(s) {
      return (s || "")
        .trim()
        .toLowerCase()
        .replace(/[^a-z\s'-]/g, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    function normalizeHangulValue(s) {
      return (s || "").trim().replace(/\s+/g, " ").trim();
    }


    // ------------------------------
    // Rule-based fallback
    // ------------------------------
    const CHO  = ["ã„±","ã„²","ã„´","ã„·","ã„¸","ã„¹","ã…","ã…‚","ã…ƒ","ã……","ã…†","ã…‡","ã…ˆ","ã…‰","ã…Š","ã…‹","ã…Œ","ã…","ã…"];
    const JUNG = ["ã…","ã…","ã…‘","ã…’","ã…“","ã…”","ã…•","ã…–","ã…—","ã…˜","ã…™","ã…š","ã…›","ã…œ","ã…","ã…","ã…Ÿ","ã… ","ã…¡","ã…¢","ã…£"];
    const JONG = ["", "ã„±","ã„²","ã„³","ã„´","ã„µ","ã„¶","ã„·","ã„¹","ã„º","ã„»","ã„¼","ã„½","ã„¾","ã„¿","ã…€","ã…","ã…‚","ã…„","ã……","ã…†","ã…‡","ã…ˆ","ã…Š","ã…‹","ã…Œ","ã…","ã…"];
    const choIndex  = Object.fromEntries(CHO.map((c,i)=>[c,i]));
    const jungIndex = Object.fromEntries(JUNG.map((c,i)=>[c,i]));
    const jongIndex = Object.fromEntries(JONG.map((c,i)=>[c,i]));

    function composeSyllable(cho, jung, jong="") {
      if (!(cho in choIndex)) cho = "ã…‡";
      if (!(jung in jungIndex)) jung = "ã…";
      if (!(jong in jongIndex)) jong = "";
      const base = 0xAC00;
      const code = base + (choIndex[cho] * 21 * 28) + (jungIndex[jung] * 28) + jongIndex[jong];
      return String.fromCharCode(code);
    }

    const VOWELS = [
      ["eigh","ì—ì´"], ["igh","ì•„ì´"],
      ["eau","ì˜¤"], ["ieu","ìœ "],
      ["ai","ì—ì´"], ["ay","ì—ì´"],
      ["ea","ì´"], ["ee","ì´"], ["ie","ì´"], ["ei","ì´"],
      ["oo","ìš°"], ["ow","ì•„ìš°"], ["ou","ì•„ìš°"],
      ["au","ì˜¤"], ["aw","ì˜¤"],
      ["oi","ì˜¤ì´"], ["oy","ì˜¤ì´"],
      ["oa","ì˜¤"], ["oe","ì˜¤"],
      ["a","ì•„"], ["e","ì—"], ["i","ì´"], ["o","ì˜¤"], ["u","ìš°"], ["y","ì´"]
    ];

    const CONS = [
      ["tch","ã…Š"], ["ch","ã…Š"], ["sh","ã……"], ["ph","ã…"],
      ["th","ã…Œ"], ["ck","ã…‹"], ["ng","ã…‡"], ["qu","ã…‹"], ["wh","ã…"],
      ["kn","ã„´"], ["wr","ã„¹"], ["ps","ã……"], ["x","ã…‹ã……"],
      ["c","ã…‹"], ["g","ã„±"], ["k","ã…‹"], ["j","ã…ˆ"], ["q","ã…‹"],
      ["r","ã„¹"], ["l","ã„¹"], ["m","ã…"], ["n","ã„´"], ["b","ã…‚"], ["p","ã…"],
      ["d","ã„·"], ["t","ã…Œ"], ["f","ã…"], ["v","ã…‚"], ["h","ã…"], ["s","ã……"], ["z","ã…ˆ"], ["w","ã…‡"],
    ];

    function tokenize(word) {
      let s = word.toLowerCase();
      const out = [];
      let i = 0;
      while (i < s.length) {
        const ch = s[i];
        if (ch === "'" || ch === "-") { i++; continue; }

        if (s[i] === "c" && (s[i+1] === "e" || s[i+1] === "i" || s[i+1] === "y")) {
          out.push({type:"C", val:"ã……"}); i += 1; continue;
        }

        let matched = false;

        for (const [pat, val] of VOWELS) {
          if (s.startsWith(pat, i)) { out.push({type:"V", val}); i += pat.length; matched = true; break; }
        }
        if (matched) continue;

        for (const [pat, val] of CONS) {
          if (s.startsWith(pat, i)) { out.push({type:"C", val}); i += pat.length; matched = true; break; }
        }
        if (matched) continue;

        i++;
      }
      return out;
    }

    function pickJung(vowelSyllables) {
      const map = [
        ["ì•„","ã…"], ["ì• ","ã…"], ["ì•¼","ã…‘"], ["ì˜ˆ","ã…–"], ["ì—","ã…”"],
        ["ì–´","ã…“"], ["ì—¬","ã…•"],
        ["ì˜¤","ã…—"], ["ì™€","ã…˜"], ["ì™œ","ã…™"], ["ì™¸","ã…š"],
        ["ìš°","ã…œ"], ["ì›Œ","ã…"], ["ì›¨","ã…"], ["ìœ„","ã…Ÿ"],
        ["ìœ ","ã… "], ["ìœ¼","ã…¡"], ["ì˜","ã…¢"], ["ì´","ã…£"],
      ];
      for (const [k,v] of map) if (vowelSyllables.startsWith(k)) return v;
      return "ã…";
    }

    function toJong(consonantJamo) {
      const last = consonantJamo.slice(-1);
      if (JONG.includes(last)) return last;
      const close = {"ã…":"ã…‚","ã…‹":"ã„±","ã…Š":"ã…ˆ","ã…Œ":"ã„·","ã…†":"ã……"};
      return (close[last] && JONG.includes(close[last])) ? close[last] : "";
    }

    function toCho(consonantJamo) {
      const first = consonantJamo[0];
      if (CHO.includes(first)) return first;
      const close = {"ã…":"ã…‚","ã…‹":"ã„±","ã…Š":"ã…ˆ","ã…Œ":"ã„·","ã…†":"ã……"};
      return (close[first] && CHO.includes(close[first])) ? close[first] : "ã…‡";
    }

    function ruleBasedHangul(word) {
      const tokens = tokenize(word);
      if (!tokens.length) return "";
      let res = "";
      let i = 0;
      while (i < tokens.length) {
        let cho = "ã…‡";
        if (tokens[i]?.type === "C") { cho = toCho(tokens[i].val); i++; }
        if (tokens[i]?.type !== "V") break;
        const jung = pickJung(tokens[i].val);
        i++;

        let jong = "";
        if (tokens[i]?.type === "C" && tokens[i+1]?.type !== "V") {
          jong = toJong(tokens[i].val);
          i++;
        }
        res += composeSyllable(cho, jung, jong);
      }
      return res;
    }

    // ------------------------------
    // Firestore helpers
    // ------------------------------
    async function getCanonical(nameKey) {
      if (canonicalCache.has(nameKey)) return canonicalCache.get(nameKey);
      try {
        const snap = await getDoc(doc(db, "canonical", nameKey));
        if (snap.exists()) {
          const data = snap.data();
          canonicalCache.set(nameKey, data);
          return data;
        }
      } catch {}
      return null;
    }

    async function fetchCommunitySuggestions(nameKey) {
      communityList.innerHTML = "";
      if (!nameKey) return;
      const q = query(
        collection(db, "suggestions"),
        where("nameKey", "==", nameKey),
        where("status", "in", ["approved", "pending"]),
        orderBy("score", "desc"),
        orderBy("reportCount", "asc"),
        orderBy("createdAt", "desc"),
        limit(8)
      );
      const snap = await getDocs(q);
      if (snap.empty) {
        communityList.innerHTML = `<div class="muted" style="margin-top:8px;">No suggestions yet.</div>`;
        return;
      }
      snap.forEach((docSnap) => {
        const s = docSnap.data();
        const row = document.createElement("div");
        row.className = "community-item";
        row.innerHTML = `
          <div>
            <div class="hangul">${escapeHtml(s.hangul)}</div>
            <div class="meta">
              <span class="mini-badge">Score ${s.score ?? 0}</span>
              <span class="mini-badge">Reports ${s.reportCount ?? 0}</span>
              <span class="mini-badge ${s.status === "approved" ? "badge-ok" : "badge-warn"}">${s.status === "approved" ? "Approved" : "Pending review"}</span>
            </div>
          </div>
          <div class="row" style="margin:0">
            <button class="btn" data-vote="up" data-id="${docSnap.id}">ğŸ‘</button>
            <button class="btn" data-vote="down" data-id="${docSnap.id}">ğŸ‘</button>
            <button class="btn" data-report="true" data-id="${docSnap.id}">Report</button>
          </div>
        `;
        communityList.appendChild(row);
      });
    }

    function isValidHangul(s) {
      return /[ê°€-í£]/.test(s || "");
    }

    function withinLimits(nameKey, hangul) {
      return nameKey.length >= 2 && nameKey.length <= 40 && hangul.length >= 1 && hangul.length <= 20;
    }

    function throttleSuggestion() {
      const last = Number(localStorage.getItem(LAST_SUGGESTION_KEY) || 0);
      const now = Date.now();
      if (now - last < 10000) return false;
      localStorage.setItem(LAST_SUGGESTION_KEY, String(now));
      return true;
    }

    async function submitSuggestion(nameKey, hangul) {
      if (!currentUser) {
        showToast("Signing in...");
        await authReady.catch(() => {});
      }
      if (!currentUser) { showToast("Auth not ready"); return; }
      if (!isValidHangul(hangul)) { showToast("Hangul required"); return; }
      if (!withinLimits(nameKey, hangul)) { showToast("Length out of range"); return; }

      const canonical = await getCanonical(nameKey);
      if (canonical && canonical.hangulBest === hangul) {
        showToast("Already official");
        return;
      }

      if (!throttleSuggestion()) {
        showToast("Please wait 10s before submitting again");
        return;
      }

      // If duplicate suggestion exists, upvote it instead of creating a new doc.
      const dupQ = query(
        collection(db, "suggestions"),
        where("nameKey", "==", nameKey),
        where("hangul", "==", hangul),
        where("status", "in", ["pending", "approved"]),
        limit(1)
      );
      const dupSnap = await getDocs(dupQ);
      if (!dupSnap.empty) {
        const dupDoc = dupSnap.docs[0];
        await voteSuggestion(nameKey, dupDoc.id, 1);
        showToast("Voted existing suggestion");
        return;
      }

      const suggestionId = crypto.randomUUID();
      await setDoc(doc(db, "suggestions", suggestionId), {
        nameKey,
        hangul,
        status: "pending",
        votesUp: 1,
        votesDown: 0,
        score: 1,
        reportCount: 0,
        createdAt: serverTimestamp(),
        createdBy: currentUser.uid
      });

      await setDoc(doc(db, "votes", `${nameKey}_${currentUser.uid}`), {
        nameKey,
        suggestionId,
        vote: 1
      });

      showToast("Submitted for review");
      await fetchCommunitySuggestions(nameKey);
    }

    async function voteSuggestion(nameKey, suggestionId, vote) {
      if (!currentUser) { showToast("Signing in..."); return; }
      const voteId = `${nameKey}_${currentUser.uid}`;
      const voteRef = doc(db, "votes", voteId);
      await runTransaction(db, async (tx) => {
        const existingVote = await tx.get(voteRef);
        if (existingVote.exists()) return;
        const suggestionRef = doc(db, "suggestions", suggestionId);
        const suggestionSnap = await tx.get(suggestionRef);
        if (!suggestionSnap.exists()) return;

        const data = suggestionSnap.data();
        const up = (data.votesUp || 0) + (vote === 1 ? 1 : 0);
        const down = (data.votesDown || 0) + (vote === -1 ? 1 : 0);
        tx.update(suggestionRef, {
          votesUp: up,
          votesDown: down,
          score: up - down
        });
        tx.set(voteRef, { nameKey, suggestionId, vote });
      });
      await fetchCommunitySuggestions(nameKey);
    }

    async function reportSuggestion(nameKey, suggestionId) {
      if (!currentUser) { showToast("Signing in..."); return; }
      const reportId = `${suggestionId}_${currentUser.uid}`;
      const reportRef = doc(db, "reports", reportId);
      await runTransaction(db, async (tx) => {
        const existingReport = await tx.get(reportRef);
        if (existingReport.exists()) return;
        const suggestionRef = doc(db, "suggestions", suggestionId);
        const suggestionSnap = await tx.get(suggestionRef);
        if (!suggestionSnap.exists()) return;
        const data = suggestionSnap.data();
        tx.update(suggestionRef, { reportCount: (data.reportCount || 0) + 1 });
        tx.set(reportRef, { suggestionId, nameKey });
      });
      showToast("Reported");
      await fetchCommunitySuggestions(nameKey);
    }

    // ------------------------------
    // Lookup order: local > canonical > built-in > rule
    // ------------------------------
    async function lookupOneWord(wordLower) {
      const custom = loadCustomDict();
      if (custom[wordLower]) return { options: [custom[wordLower]], source: "custom" };

      const canonical = await getCanonical(wordLower);
      if (canonical?.hangulBest) {
        const alts = Array.isArray(canonical.alts) ? canonical.alts : [];
        return { options: [canonical.hangulBest, ...alts].filter(Boolean).slice(0,3), source: "canonical" };
      }

      if (BUILTIN_DICT.has(wordLower)) return { options: BUILTIN_DICT.get(wordLower), source: "builtin" };

      const base = ruleBasedHangul(wordLower);
      let thVariant = "";
      if (wordLower.includes("th")) thVariant = ruleBasedHangul(wordLower.replaceAll("th", "s"));
      const opts = [base, thVariant].filter(Boolean);
      return { options: [...new Set(opts)].slice(0, 3), source: "rule" };
    }

    function sourceLabel(src){
      if (src === "custom") return "Custom dictionary";
      if (src === "canonical") return "Canonical";
      if (src === "builtin") return "Built-in dictionary";
      return "Rule-based fallback";
    }

    async function renderResults(rawInput, wordResults, combinedOptions, combinedSource) {
      resultsEl.innerHTML = "";

      if (!combinedOptions.length) {
        resultsEl.innerHTML = `<div class="result"><div><div class="hangul">â€”</div><div class="meta">Couldnâ€™t parse that. Please use letters only.</div></div></div>`;
        return;
      }

      combinedOptions.forEach((ko, idx) => {
        const el = document.createElement("div");
        el.className = "result";
        el.innerHTML = `
          <div>
            <div class="hangul">${escapeHtml(ko)}</div>
            <div class="meta">
              <span class="mini-badge">${idx === 0 ? "Recommended" : "Alternative"}</span>
              <span class="mini-badge">${escapeHtml(sourceLabel(combinedSource))}</span>
            </div>
          </div>
          <div class="row" style="margin:0">
            <button class="btn green" style="padding:10px 12px;border-radius:14px">Copy</button>
            <button class="btn" style="padding:10px 12px;border-radius:14px">Submit suggestion (reviewed before publication)</button>
          </div>
        `;
        const [copyBtn, fixBtn] = el.querySelectorAll("button");
        copyBtn.addEventListener("click", () => copyText(ko));
        fixBtn.addEventListener("click", () => setSuggestionFromOutput(rawInput, ko));
        resultsEl.appendChild(el);
      });

      const debug = document.createElement("div");
      debug.className = "muted";
      debug.style.marginTop = "8px";
      debug.innerHTML = wordResults.map(wr => {
        const s = wr.source === "custom" ? "custom" : (wr.source === "canonical" ? "canonical" : (wr.source === "builtin" ? "dict" : "rule"));
        return `${escapeHtml(wr.word)} <span style="opacity:.7">(${s})</span>`;
      }).join(" Â· ");
      resultsEl.appendChild(debug);
    }

    async function convert() {
      const raw = nameInput.value.trim();
      if (!raw) { resultsEl.innerHTML = ""; return; }

      const cleaned = raw
        .replace(/[^a-zA-Z\s'-]/g, "")
        .replace(/\s+/g, " ")
        .trim();

      if (!cleaned) { resultsEl.innerHTML = ""; return; }

      const words = cleaned.split(" ").map(w => w.trim()).filter(Boolean);
      const wordResults = [];
      for (const w of words) {
        const key = normalizeEnglishKey(w);
        const res = await lookupOneWord(key);
        wordResults.push({ word: w, key, options: res.options, source: res.source });
      }

      const combined = [];
      for (let i = 0; i < 3; i++) {
        const parts = wordResults.map(wr => wr.options[i] || wr.options[0]).filter(Boolean);
        if (parts.length) combined.push(parts.join(" "));
      }
      const combinedOptions = [...new Set(combined)].slice(0, 3);

      const anyCustom = wordResults.some(w => w.source === "custom");
      const anyCanonical = wordResults.some(w => w.source === "canonical");
      const allBuiltin = wordResults.every(w => w.source === "builtin");
      const combinedSource = anyCustom ? "custom" : (anyCanonical ? "canonical" : (allBuiltin ? "builtin" : "rule"));

      await renderResults(raw, wordResults, combinedOptions, combinedSource);

      lastNameKey = normalizeEnglishKey(raw);
      lastRecommended = combinedOptions[0] || "";
      lastSource = combinedSource;
      suggestKey.value = lastNameKey;
      suggestHangul.value = lastRecommended;

      const firstKey = wordResults[0]?.key || "";
      if (firstKey) {
        fetchCommunitySuggestions(firstKey).catch(() => {});
      }
    }

    $("#convertBtn").addEventListener("click", convert);
    nameInput.addEventListener("keydown", (e) => { if (e.key === "Enter") convert(); });

    function setSuggestionFromOutput(en, ko) {
      suggestKey.value = normalizeEnglishKey(en);
      suggestHangul.value = ko;
      document.getElementById("community").scrollIntoView({ behavior: "smooth", block: "start" });
    }

    submitSuggestionBtn.addEventListener("click", () => {
      const key = normalizeEnglishKey(suggestKey.value || nameInput.value);
      const hangul = normalizeHangulValue(suggestHangul.value);
      if (!key || key.length < 2) { showToast("Enter an English name"); return; }
      if (!hangul) { showToast("Enter a Hangul spelling"); return; }
      const isKnownSource = (lastSource === "custom" || lastSource === "canonical" || lastSource === "builtin");
      if (isKnownSource && key === lastNameKey && hangul === lastRecommended) {
        showToast("Already official. No suggestion needed.");
        return;
      }
      submitSuggestion(key, hangul).catch((err) => {
        console.error("submitSuggestion failed", err);
        showToast(err?.message ? `Failed: ${err.message}` : "Failed to submit");
      });
    });

    communityList.addEventListener("click", (e) => {
      const btn = e.target.closest("button");
      if (!btn) return;
      const suggestionId = btn.getAttribute("data-id");
      if (!suggestionId) return;
      const nameKey = normalizeEnglishKey(suggestKey.value || nameInput.value);
      if (btn.getAttribute("data-vote") === "up") {
        voteSuggestion(nameKey, suggestionId, 1).catch(() => showToast("Vote failed"));
      } else if (btn.getAttribute("data-vote") === "down") {
        voteSuggestion(nameKey, suggestionId, -1).catch(() => showToast("Vote failed"));
      } else if (btn.getAttribute("data-report")) {
        reportSuggestion(nameKey, suggestionId).catch(() => showToast("Report failed"));
      }
    });

    nameInput.focus();
  </script>
</body>
</html>
